function $Resolve(e,t){var n=1,r=2,i={},s=[],o=i,u=extend(e.when(i),{$$promises:i,$$values:i});this.study=function(i){function h(e,o){if(c[o]===r)return;l.push(o);if(c[o]===n)throw l.splice(0,indexOf(l,o)),new Error("Cyclic dependency: "+l.join(" -> "));c[o]=n;if(isString(e))f.push(o,[function(){return t.get(e)}],s);else{var u=t.annotate(e);forEach(u,function(e){e!==o&&i.hasOwnProperty(e)&&h(i[e],e)}),f.push(o,e,u)}l.pop(),c[o]=r}function p(e){return isObject(e)&&e.then&&e.$$promises}if(!isObject(i))throw new Error("'invocables' must be an object");var a=objectKeys(i||{}),f=[],l=[],c={};return forEach(i,h),i=l=c=null,function(n,r,i){function m(){--d||(v||merge(h,r.$$values),l.$$values=h,l.$$promises=l.$$promises||!0,delete l.$$inheritedValues,s.resolve(h))}function g(e){l.$$failure=e,s.reject(e)}function w(r,s,o){function f(e){u.reject(e),g(e)}function p(){if(isDefined(l.$$failure))return;try{u.resolve(t.invoke(s,i,h)),u.promise.then(function(e){h[r]=e,m()},f)}catch(e){f(e)}}var u=e.defer(),a=0;forEach(o,function(e){c.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(a++,c[e].then(function(t){h[e]=t,--a||p()},f))}),a||p(),c[r]=u.promise}p(n)&&i===undefined&&(i=r,r=n,n=null);if(!n)n=o;else if(!isObject(n))throw new Error("'locals' must be an object");if(!r)r=u;else if(!p(r))throw new Error("'parent' must be a promise returned by $resolve.resolve()");var s=e.defer(),l=s.promise,c=l.$$promises={},h=extend({},n),d=1+f.length/3,v=!1;if(isDefined(r.$$failure))return g(r.$$failure),l;r.$$inheritedValues&&merge(h,omit(r.$$inheritedValues,a)),extend(c,r.$$promises),r.$$values?(v=merge(h,omit(r.$$values,a)),l.$$inheritedValues=omit(r.$$values,a),m()):(r.$$inheritedValues&&(l.$$inheritedValues=omit(r.$$inheritedValues,a)),r.then(m,g));for(var y=0,b=f.length;y<b;y+=3)n.hasOwnProperty(f[y])?m():w(f[y],f[y+1],f[y+2]);return l}},this.resolve=function(e,t,n,r){return this.study(e)(t,n,r)}}$Resolve.$inject=["$q","$injector"],angular.module("ui.router.util").service("$resolve",$Resolve)